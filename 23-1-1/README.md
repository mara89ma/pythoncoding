## 시간복잡도

- 연산하는 기기마다 성능이 다르므로 시간 소요가 아니라, **연산 횟수**를 기준으로 계산

### 유형

- 빅 오메가 Ω :  주어진 알고리즘보다 시간복잡도가 느릴때
- 빅 세타 θ : 빅오메가와 빅 오가 같을 때
- 빅 오 O: 주어진 알고리즘 시간복잡도보다 같거나 더 크면 됨

O(N) O(N^2)

Ω(1) Ω(N)

θ(N)

```python
N = int(input())
M = int(input())

s = 0
for i in range(N):
    for j in range(M):
        if i + j != 10:
            s = s + i

print(s)
```

## 공간 복잡도

- 특정한 크기의 입력에 대하여 알고리즘이 얼마나 **많은 메모리를 차지하는지**
    - 변수를 선언하거나 요소들을 담을 공간이 메모리가 필요한데 이게 공간복잡도
- 정적, 동적 함수 모두

시간복잡도와 공간복잡도 관계 trade off

- 기록이 많으면(공간) 시간이 줄어든다(시간) / 기록이 적으면(공간) 시간이 늘어난다(시간)

## 배열

- 크기를 바꿀 수 없음 연속된 데이터를 가짐
- 인덱스를 가짐
- 같은 자료형의 데이터들을 하나의 변수로 정의함
- 메모리주소가 순차적

**특정/임의의 인덱스의 값을 읽어오는 기능**

- array[0]
- array[3] ⇒ 한번에 바로 조회 가능

**특정 인덱스의 값을 수정하는 기능**

- 바로 수정 가능

**시간 복잡도**

- **특정/임의의 인덱스의 값을 읽어오는 기능**: n번째 인덱스에서 해당하는 값을 찾아내는 연산, O(1)의 시간복잡도를 가짐 → 자료마다 인덱스를 부여했기 때문
- **특정 인덱스의 값을 수정하는 기능**: O(1) - 자료마다 인덱스가 있어서, 수정하고자할때 해당 인덱스로 가서 수정하면 된다.

## 리스트

- 값을 삽입, 삭제하기 위해서 사용하는 자료 구조
- 인덱스가 없으며, 본래 정해져있는 크기가 없음

- 다음위치로 이동하는 기능이 있음
- 현재 위치의 값을 읽어 올 수 있는 기능이 있음
- 현재 위치의 값을 삭제할 수 있는 기능이 있음
- 현재 위치의 값을 추가 하는 기능이 있음

**검색 (핵심기능 x)**

- list[0]
- list[3] ⇒ 바로 찾을 수 없고, 하나하나값을 검색해서 다음 값을 찾음

현재 위치의 값을 **삭제**

- 가리키는 포인터만 바뀜
- 메모리 낭비 x

현재 위치의 값을 **추가**

- 메모리 공간 효율적 사용

**시간 복잡도 O(1)**

- 다음위치로 이동하는 기능이 있음
- 현재 위치의 값을 읽어 올 수 있는 기능이 있음
- 현재 위치의 값을 삭제할 수 있는 기능이 있음
- 현재 위치의 값을 추가 하는 기능이 있음

## 스택

- top : 가장 위에 있는 데이터

LIFO(Last-in, First Out) → 마지막에 삽입한 데이터를 가장 먼저 사용

**<필수>**

**Push**

- **item 넣기**

**pop**

- **item 제거**

**<필수 x>**

peek

- 가장 위에 있는 데이터를 보는 기능
- 필수 연산 x
- pop → push ⇒ peek

**시간복잡도**

- 삭제 삽입 : O(1) : 삭제나 삽입시 맨 위에 데이터를 삽입하거나 삭제하기 때문

스택의 **공간복잡도 _O(n) 데이터갯수만큼**

## 큐

- 헤드(front) : 맨앞에 있는 데이터를 가리키는 포인터
- 테일(rear) : 맨 뒤에 있는 데이터를 가리키는 포인터

FIFO (가장 먼저 줄 선 사람이 먼저 서비스를 받음)

- enqueue = push
    - item 넣기
- dequeue = pop
    - item 제거
- peek : pop,push를 n번

**시간 복잡도,**

- enqueue: O(1) : 맨 뒤에 자료가 삽입되는 연산만 수행하므로,
- dequeue : O(1) : 맨 앞에 있는 자료에 연산만 수행하므로

**공간 복잡도(메모리사용) → O(n)**
