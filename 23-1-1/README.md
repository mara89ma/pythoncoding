# 시간복잡도와 공간복잡도

## 시간복잡도

- 연산하는 기기마다 성능이 다르므로 시간 소요가 아니라, **연산 횟수**를 기준으로 계산

### 유형

- 빅 오메가 : 최선일 때 연산 횟수
- 빅 세타 : 보통일 때 연산 횟수
- **빅 오 : 최악일 때 연산 횟수**

## 공간 복잡도

- 특정한 크기의 입력에 대하여 알고리즘이 얼마나 **많은 메모리를 차지하는지**
    - 변수를 선언하거나 요소들을 담을 공간이 메모리가 필요한데 이게 공간복잡도
- 정적, 동적 함수 모두

## 배열

- 같은 자료형의 데이터들을 하나의 변수로 정의함
- 메모리주소가 순차적

**검색**

- array[0]
- array[3] ⇒ 한번에 바로 검색 가능

**삭제**

- 바로 삭제 가능
- 메모리 공간이 남음 (메모리 낭비)
- 앞으로 값을 땡겨와야해서 시간도 소요

**삽입**

- 메모리 낭비

**시간 복잡도**

- 접근 : n번째 인덱스에서 해당하는 값을 찾아내는 연산, O(1)의 시간복잡도를 가짐 → 자료마다 인덱스를 부여했기 때문
- 삽입,제거: O(n): 차례대로 한칸씩 밀어서 삽입해야 하므로, O(n)의 시간 복잡도
- 할당 : O(1) - 자료마다 인덱스가 있어서, 수정하고자할때 해당 인덱스로 가서 수정하면 된다.
- 탐색 : O(n) 특정 값을 찾기 위해서는 모든 요소를 살펴봐야하기 때문에

## 리스트

- 서로 다른 자료형의 데이터들을 하나의 변수로 정의
- 메모리주소가 랜덤
- 인덱스가 없으며, 본래 정해져있는 크기가 없음
- 노드로 구성되어 있으며

<single linked list>

<doubly linked list>

**검색**

- list[0]
- list[3] ⇒ 바로 찾을 수 없고, 하나하나값을 검색해서 다음 값을 찾음

**삭제**

- 가리키는 포인터만 바뀜
- 메모리 낭비 x

**추가**

- 메모리 공간 효율적 사용

**시간 복잡도**

**접근** : O(n) :  하나하나 값을 검색해서 다음 값에 접근 해야 하기 때문.

**삽입,삭제** : O(1) : 링크만 수정하면 사용가능하기 때문

**찾기** : O(n) 하나하나 값을 검색해서 다음 값을 찾아야 하기 때문

## 스택

LIFO(Last-in, First Out) → 마지막에 삽입한 데이터를 가장 먼저 사용

Push

- item 넣기

pop

- item 제거

peek

- item 검색

**시간복잡도**

- 삭제 삽입 변경 : O(1) : 삭제나 삽입시 맨 위에 데이터를 삽입하거나 삭제하기 때문
- 찾기 : O(n): 특정 데이터를 찾을 때는 특정 데이터를 찾을 때까지 수행해야하므로, O(n)의 시간복잡도를 가짐

**공간복잡도 (메모리사용)**

- 삭제 삽입 변경 : O(1)
- 찾기 : O(n)

## 큐

FIFO (가장 먼저 줄 선 사람이 먼저 서비스를 받음)

- enqueue
    - item 넣기
- dequeue
    - item 제거
- peek
    - item 검색

**시간 복잡도,공간 복잡도(메모리사용)**

- 삽입 : O(1) : 맨 뒤에 자료가 삽입되는 연산만 수행하므로,
- 삭제 : O(1) : 맨 앞에 있는 자료에 연산만 수행하므로
- 검색 : O(n) : 맨 앞부터 맨 마지막까지 차례대로 검색해야되기 때문에
